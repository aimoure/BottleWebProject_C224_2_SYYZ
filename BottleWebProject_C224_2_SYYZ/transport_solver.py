import numpy as np
from collections import defaultdict

# Метод северо-западного угла для начального базисного решения.
# Принимает матрицу стоимостей, запасы и потребности, возвращает план.
# Описывается метод северо-западного угла, который формирует начальный план распределения.

def northwest_corner_method(cost_matrix, supply, demand):
    # Определяется функция для реализации метода северо-западного угла.
    supply = supply.copy()
    # Создается копия массива запасов для предотвращения изменения исходных данных.
    demand = demand.copy()
    # Создается копия массива потребностей для предотвращения изменения исходных данных.
    rows, cols = len(supply), len(demand)
    # Определяются размеры матрицы: количество строк (поставщики) и столбцов (потребители).
    plan = np.zeros((rows, cols))
    # Создается нулевая матрица плана распределения размером rows x cols.
    i = j = 0
    # Инициализируются индексы для строк (i) и столбцов (j).
    # Заполняет план, начиная с верхнего левого угла.
    # Описывается процесс заполнения плана с использованием метода северо-западного угла.
    while i < rows and j < cols:
        # Цикл продолжается, пока не обработаны все строки или столбцы.
        if supply[i] == 0:
            # Проверяется, исчерпан ли запас текущего поставщика.
            i += 1
            # Если запас исчерпан, переходит к следующей строке.
            continue
            # Продолжается цикл с новой итерацией.
        if demand[j] == 0:
            # Проверяется, удовлетворена ли потребность текущего потребителя.
            j += 1
            # Если потребность удовлетворена, переходит к следующему столбцу.
            continue
            # Продолжается цикл с новой итерацией.
        amount = min(supply[i], demand[j])
        # Определяется минимальное значение между текущим запасом и потребностью.
        plan[i, j] = amount
        # Записывается найденное количество в план для текущей клетки.
        supply[i] -= amount
        # Уменьшается запас текущего поставщика на выделенное количество.
        demand[j] -= amount
        # Уменьшается потребность текущего потребителя на выделенное количество.
        if supply[i] == 0:
            # Проверяется, исчерпан ли запас текущего поставщика после распределения.
            i += 1
            # Если запас исчерпан, переходит к следующей строке.
        if demand[j] == 0:
            # Проверяется, удовлетворена ли потребность текущего потребителя после распределения.
            j += 1
            # Если потребность удовлетворена, переходит к следующему столбцу.
    return plan
    # Возвращается сформированный начальный план распределения.

# Проверяет наличие цикла в базисе.
# Использует граф для поиска цикла методом DFS.
# Описывается функция для проверки наличия цикла в базисных клетках с использованием метода поиска в глубину.

def has_cycle(basis):
    # Определяется функция для проверки наличия цикла в базисе.
    graph = defaultdict(list)
    # Создается граф в виде словаря, где ключи — строки и столбцы, значения — списки связанных узлов.
    for i, j in basis:
        # Перебираются базисные клетки (i, j).
        graph[f"r{i}"].append(f"c{j}")
        # Добавляется ребро от строки i к столбцу j в графе.
        graph[f"c{j}"].append(f"r{i}")
        # Добавляется ребро от столбца j к строке i в графе.
    visited = set()
    # Создается множество для хранения посещенных узлов.
    def dfs(node, parent):
        # Определяется вспомогательная функция для поиска в глубину.
        visited.add(node)
        # Текущий узел помечается как посещенный.
        for neighbor in graph[node]:
            # Перебираются соседи текущего узла.
            if neighbor == parent:
                # Пропускается родительский узел, чтобы избежать возврата по тому же пути.
                continue
                # Продолжается цикл с новой итерацией.
            if neighbor in visited or dfs(neighbor, node):
                # Проверяется, посещался ли сосед ранее, или выполняется рекурсивный поиск.
                return True
                # Возвращается True, если найден цикл.
        return False
        # Возвращается False, если цикл не найден.
    for node in graph:
        # Перебираются все узлы графа.
        if node not in visited:
            # Проверяется, не посещался ли текущий узел.
            if dfs(node, None):
                # Выполняется поиск в глубину для текущего узла.
                return True
                # Возвращается True, если найден цикл.
    return False
    # Возвращается False, если цикл не найден.

# Формирует базис из текущего плана.
# Добавляет нулевые клетки с минимальной стоимостью, если нужно.
# Описывается функция для формирования базиса из плана, добавляя нулевые клетки при необходимости.

def get_basis(plan, cost_matrix):
    # Определяется функция для формирования базиса.
    basis = [(i, j) for i in range(plan.shape[0]) for j in range(plan.shape[1]) if plan[i, j] > 0]
    # Формируется список базисных клеток, где значения плана больше нуля.
    rows, cols = plan.shape
    # Определяются размеры плана: количество строк и столбцов.
    needed = rows + cols - 1
    # Вычисляется необходимое количество базисных клеток (m + n - 1).
    zero_cells = sorted(
        [(i, j) for i in range(rows) for j in range(cols) if plan[i, j] == 0 and (i, j) not in basis],
        key=lambda cell: cost_matrix[cell[0], cell[1]]
    )
    # Формируется отсортированный список нулевых клеток по возрастанию стоимости.
    for i, j in zero_cells:
        # Перебираются нулевые клетки.
        temp_basis = basis + [(i, j)]
        # Добавляется текущая нулевая клетка к базису для проверки.
        if not has_cycle(temp_basis):
            # Проверяется, не создает ли новая клетка цикл в базисе.
            basis.append((i, j))
            # Если цикл не создается, клетка добавляется в базис.
            if len(basis) == needed:
                # Проверяется, достигнуто ли необходимое количество базисных клеток.
                break
                # Прерывается цикл, если базис полный.
    return basis
    # Возвращается сформированный базис.

# Вычисляет потенциалы u и v для базисных клеток.
# Используется для проверки оптимальности плана.
# Описывается функция для вычисления потенциалов u и v для базисных клеток.

def calculate_potentials(cost_matrix, basis):
    # Определяется функция для вычисления потенциалов.
    rows, cols = cost_matrix.shape
    # Определяются размеры матрицы стоимостей.
    u = [None] * rows
    # Создается список для потенциалов строк (u) с начальными значениями None.
    v = [None] * cols
    # Создается список для потенциалов столбцов (v) с начальными значениями None.
    u[0] = 0
    # Устанавливается начальное значение потенциала первой строки равным 0.
    changed = True
    # Инициализируется флаг для отслеживания изменений в потенциалах.
    while changed:
        # Цикл продолжается, пока происходят изменения в потенциалах.
        changed = False
        # Флаг сбрасывается перед каждой итерацией.
        for i, j in basis:
            # Перебираются базисные клетки.
            if u[i] is not None and v[j] is None:
                # Проверяется, известен ли u[i] и неизвестен ли v[j].
                v[j] = cost_matrix[i][j] - u[i]
                # Вычисляется потенциал v[j] по формуле: v[j] = c[i,j] - u[i].
                changed = True
                # Устанавливается флаг изменения.
            elif u[i] is None and v[j] is not None:
                # Проверяется, неизвестен ли u[i] и известен ли v[j].
                u[i] = cost_matrix[i][j] - v[j]
                # Вычисляется потенциал u[i] по формуле: u[i] = c[i,j] - v[j].
                changed = True
                # Устанавливается флаг изменения.
    u = [0 if x is None else x for x in u]
    # Заменяются значения None в u на 0.
    v = [0 if x is None else x for x in v]
    # Заменяются значения None в v на 0.
    return u, v
    # Возвращаются списки потенциалов u и v.

# Находит цикл для перераспределения ресурсов.
# Использует графическое представление базиса.
# Описывается функция для поиска цикла в базисе для перераспределения ресурсов.

def find_cycle(basis, start):
    # Определяется функция для поиска цикла, начиная с указанной клетки.
    row_to_cols = defaultdict(list)
    # Создается словарь, где ключи — строки, значения — списки столбцов.
    col_to_rows = defaultdict(list)
    # Создается словарь, где ключи — столбцы, значения — списки строк.
    for i, j in basis:
        # Перебираются базисные клетки.
        row_to_cols[i].append(j)
        # Добавляется столбец j к строке i.
        col_to_rows[j].append(i)
        # Добавляется строка i к столбцу j.
    i, j = start
    # Извлекаются координаты начальной клетки (i, j).
    path = [(i, j)]
    # Инициализируется путь с начальной клеткой.
    visited_rows = {i}
    # Создается множество посещенных строк, начиная с i.
    visited_cols = set()
    # Создается пустое множество посещенных столбцов.
    def backtrack(current_i, current_j, is_row):
        # Определяется вспомогательная функция для поиска пути с возвратом.
        if is_row:
            # Проверяется, находится ли поиск в строке.
            for next_j in row_to_cols[current_i]:
                # Перебираются столбцы, связанные с текущей строкой.
                if next_j == current_j or next_j in visited_cols:
                    # Пропускается текущий столбец или уже посещенный столбец.
                    continue
                    # Продолжается цикл с новой итерацией.
                visited_cols.add(next_j)
                # Добавляется новый столбец в посещенные.
                path.append((current_i, next_j))
                # Добавляется клетка в путь.
                result = backtrack(current_i, next_j, False)
                # Рекурсивно продолжается поиск в столбце.
                if result:
                    # Проверяется, найден ли цикл.
                    return result
                    # Возвращается найденный цикл.
                path.pop()
                # Удаляется клетка из пути при возврате.
                visited_cols.remove(next_j)
                # Удаляется столбец из посещенных при возврате.
        else:
            # Проверяется, находится ли поиск в столбце.
            for next_i in col_to_rows[current_j]:
                # Перебираются строки, связанные с текущим столбцом.
                if next_i == current_i:
                    # Пропускается текущая строка.
                    continue
                    # Продолжается цикл с новой итерацией.
                if next_i in visited_rows:
                    # Проверяется, посещалась ли строка ранее.
                    if len(path) >= 4 and path[0][0] == next_i:
                        # Проверяется, можно ли замкнуть цикл (длина >= 4 и возврат в начальную строку).
                        return path
                        # Возвращается найденный цикл.
                    continue
                    # Продолжается цикл с новой итерацией.
                visited_rows.add(next_i)
                # Добавляется новая строка в посещенные.
                path.append((next_i, current_j))
                # Добавляется клетка в путь.
                result = backtrack(next_i, current_j, True)
                # Рекурсивно продолжается поиск в строке.
                if result:
                    # Проверяется, найден ли цикл.
                    return result
                    # Возвращается найденный цикл.
                path.pop()
                # Удаляется клетка из пути при возврате.
                visited_rows.remove(next_i)
                # Удаляется строка из посещенных при возврате.
        return None
        # Возвращается None, если цикл не найден.
    return backtrack(i, j, True)
    # Запускается поиск цикла, начиная с строки, и возвращается результат.

# Основная функция оптимизации.
# Итеративно улучшает план до достижения оптимального решения.
# Описывается основная функция, реализующая метод потенциалов для оптимизации плана.

def optimize_transportation(cost_matrix, supply, demand):
    # Определяется основная функция для оптимизации транспортной задачи.
    cost_matrix = np.array(cost_matrix)
    # Преобразуется матрица стоимостей в массив numpy.
    supply = np.array(supply)
    # Преобразуется массив запасов в массив numpy.
    demand = np.array(demand)
    # Преобразуется массив потребностей в массив numpy.
    plan = northwest_corner_method(cost_matrix, supply, demand)
    # Формируется начальный план с использованием метода северо-западного угла.
    max_iterations = 100
    # Устанавливается максимальное количество итераций для предотвращения бесконечного цикла.
    iteration = 0
    # Инициализируется счетчик итераций.
    while iteration < max_iterations:
        # Цикл продолжается, пока не достигнуто максимальное количество итераций.
        iteration += 1
        # Увеличивается счетчик итераций.
        basis = get_basis(plan, cost_matrix)
        # Формируется базис на основе текущего плана.
        u, v = calculate_potentials(cost_matrix, basis)
        # Вычисляются потенциалы u и v для базисных клеток.
        min_delta = float('inf')
        # Инициализируется минимальная дельта для поиска неоптимальной клетки.
        min_cell = None
        # Инициализируется переменная для хранения координат клетки с минимальной дельтой.
        has_negative = False
        # Инициализируется флаг наличия отрицательной дельты.
        # Проверяет неоптимальность плана по отрицательным дельта.
        # Описывается процесс проверки оптимальности текущего плана.
        for i in range(cost_matrix.shape[0]):
            # Перебираются строки матрицы стоимостей.
            for j in range(cost_matrix.shape[1]):
                # Перебираются столбцы матрицы стоимостей.
                if (i, j) not in basis:
                    # Проверяется, не является ли клетка базисной.
                    delta = cost_matrix[i, j] - u[i] - v[j]
                    # Вычисляется дельта для неоптимальности: c[i,j] - u[i] - v[j].
                    if delta < min_delta:
                        # Проверяется, является ли текущая дельта минимальной.
                        min_delta = delta
                        # Обновляется минимальная дельта.
                        min_cell = (i, j)
                        # Сохраняются координаты клетки с минимальной дельтой.
                    if delta < -1e-10:
                        # Проверяется, является ли дельта отрицательной (с учетом погрешности).
                        has_negative = True
                        # Устанавливается флаг наличия отрицательной дельты.
        if not has_negative:
            # Проверяется, найдены ли отрицательные дельты.
            break
            # Если отрицательных дельт нет, план оптимален, цикл прерывается.
        new_basis = basis + [min_cell]
        # Добавляется клетка с минимальной дельтой к базису.
        cycle = find_cycle(new_basis, min_cell)
        # Находит цикл, начинающийся с новой клетки.
        if not cycle:
            # Проверяется, найден ли цикл.
            break
            # Если цикл не найден, процесс прерывается.
        # Перераспределяет объемы по найденному циклу.
        # Описывается процесс перераспределения объемов в плане по циклу.
        minus_cells = [cycle[k] for k in range(len(cycle)) if k % 2 == 1]
        # Формируется список клеток цикла с отрицательным знаком (минусовые клетки).
        min_q = min(plan[i, j] for i, j in minus_cells)
        # Находит минимальное значение в минусовых клетках для перераспределения.
        for k, (i, j) in enumerate(cycle):
            # Перебираются клетки цикла.
            if k % 2 == 0:
                # Проверяется, является ли клетка плюсовой (четный индекс).
                plan[i, j] += min_q
                # Увеличивается значение в плюсовой клетке на минимальное количество.
            else:
                # Проверяется, является ли клетка минусовой (нечетный индекс).
                plan[i, j] -= min_q
                # Уменьшается значение в минусовой клетке на минимальное количество.
        plan = np.where(plan < 1e-10, 0, plan)
        # Значения плана, близкие к нулю, обнуляются для устранения погрешностей.
    total_cost = np.sum(plan * cost_matrix)
    # Вычисляется общая стоимость плана как сумма произведений плана и матрицы стоимостей.
    return plan.tolist(), total_cost
    # Возвращается оптимизированный план в виде списка и общая стоимость.